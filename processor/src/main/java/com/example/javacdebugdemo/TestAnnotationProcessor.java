package com.example.javacdebugdemo;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.ElementScanner9;

import java.io.IOException;
import java.io.Writer;
import java.time.ZonedDateTime;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

@SupportedAnnotationTypes("com.example.javacdebugdemo.TestAnnotation")
public class TestAnnotationProcessor extends AbstractProcessor {

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

        AtomicReference<String> originalPackageName = new AtomicReference<>();
        AtomicReference<String> originalTypeName = new AtomicReference<>();

        var visitor = new ElementScanner9<Void, Void>() {

            @Override
            public Void visitType(TypeElement e, Void unused) {
                String simpleName = e.getSimpleName().toString();
                originalTypeName.set(simpleName);
                String packageName = e.getQualifiedName().toString();
                packageName = packageName.substring(
                    0, Math.max(packageName.length() - simpleName.length() - 1, 0)
                );
                if (!packageName.isEmpty()) {
                    originalPackageName.set(packageName);
                }

                return super.visitType(e, unused);
            }
        };

        if (annotations.isEmpty()) return false;

        roundEnv.getRootElements().forEach(element -> {

            visitor.scan(element);

            try {

                String packageNamePrefix =
                    originalPackageName.get() != null ? originalPackageName.get() + '.' : "";

                var sourceObject = processingEnv.getFiler().createSourceFile(
                    packageNamePrefix + originalTypeName.get() + "Impl", element
                );

                try (Writer writer = sourceObject.openWriter()) {
                    writer.write("/* Generated by " + getClass().getSimpleName() + " on " + ZonedDateTime.now() + " */\n");
                    if (originalPackageName.get() != null) {
                        writer.write("package " + originalPackageName.get() + ";\n\n");
                        writer.write("import " + originalPackageName.get() + "." + originalTypeName.get() + ";\n\n");
                    }
                    writer.write(
                        "public class " + originalTypeName.get() + "Impl implements " + originalTypeName.get() + " { " +
                            "public static void main(String[] args) { " +
                            "System.out.println(\"Hello, world!\"); " +
                            "} " +
                            "}"
                    );
                }

            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });

        return false;
    }

}
